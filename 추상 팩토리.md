# 추상 팩토리 (Abstract Factory)  

## 의도  

상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다.  

## 활용성  

객체가 생성되거나 구성, 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때  

여러 제품군 중 하나를 선택해서 시스템을 설정해야 하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때  

제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출 시키고 싶을 때  

## 참여자  

1. 추상 팩토리  

2. 추상 팩토리가 정의하는 인터페이스를 구현한 팩토리  

3. 추상 프로덕트  

4. 추상 프로덕트가 정의하는 인터페이스를 구현한 프로덕트

5. 추상 팩토리 및 추상 프로덕트에 선언된 인터페이스를 사용하는 client


## 협력 방법  
  
일반적으로 구체 팩토리 클래스 (추상 클래스의 인터페이스를 구현한 팩토리 클래스)가 런타임에 만들어지며,  
  
이 구체 팩토리 클래스는 특정 구현을 갖는 프로덕트 객체를 생성합니다.  이때 다른 구현을 갖는 프로덕트 객체 생성을 위해서는  

그 객체에 해당하는 팩토리 클래스를 사용하여야 합니다.  

추상 팩토리 클래스는 필요한 제품 객체를 생성하는 책임을 구체 팩토리 클래스에 위임합니다.  


## 추상 팩토리를 쓰는 장단점  

1. 구체적인 클래스를 분리합니다.  

팩토리는 프로덕트 객체를 생성하는 과정과 책임을 캡슐화 한 것이기 때문에, 구체적인 구현 클래스가 사용자에게서 분리됩니다.  

프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작하므로, 사용자의 코드에서는 나타나지 않습니다.  


2. 제품군(프로덕트)을 쉽게 대체할 수 있습니다.  

구체 팩토리의 변경만으로 응용프로그램은 서로 다른 프로덕트를 사용할 수 있게 됩니다.  

추상 팩토리는 팩토리 안에서 필요한 모든 것들을 생성하기 때문에 팩토리의 변경만으로 제품군을 변경 할 수 있습니다.  


3. 제품 사이의 일관성을 증진시킵니다.  

하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한번에 오직 한 군에서 만든 객체를 사용하도록 함으로써  

프로그램의 일관성을 갖도록 해야합니다. 이때 추상 팩토리는 이 점을 쉽게 보장할 수 있습니다.  


4. 새로운 종류의 제품을 제공하기가 어렵습니다.  

새로운 종류의 제품이 등장하면 팩토리의 구현을 변경하여야 하므로 모든 서브클래스들의 변경을 가져옵니다.  


## 예제 코드  

```
// 추상 팩토리

class MazeFactory{
public:
	MazeFactory();

	virtual Maze* MakeMaze) const
		{ return new Maze;}
	virtual Wall* MakeWall() const
		{ return new Wall;}
	virtual Room* MakeRoom(int n) const
		{ return new Room(n);}
	vitrual Door* MakeDoor(Room* r1, Room* r2) const
		{ return new Door(r1,r2);}
};
```
  
```
// 팩토리를 이용하여 미로를 만드는 메서드

// 파라미터로 MazeFactory를 상속한 구체클래스를 넘긴다면, 코드의 변경없이 쉽게 제품군을 변경할 수 있다.

Maze* MazeGame::CreateMaze(MazeFactory* factory){
	Maze* aMaze = factory.MakeMaze();
	Room* r1 = factory.MakeRoom(1);
	Room* r2 = factory.MakeRoom(2);
	Door* aDoor = factory.MakeDoor(r1,r2);

	aMaze->AddRoom(r1);
	...
}
``

```
// 클라이언트에서 단순히 팩토리만 바꾸어 호출하는 예시

MazeGame game;
BombedMazeFactory factory;


// 폭탄이 있는 미로를 만드는 팩토리를 넘겨 미로를 만들도록 함.
game.CreateMaze(factory);
````
